# Build Progress: Account Lockout Notifications

## Status: Planning Complete ✓

## 2026-01-04: Initial Planning

### Codebase Analysis Complete
- Reviewed django-axes configuration in `backend/config/settings/base.py`
- Examined existing email infrastructure in `backend/api/email.py`
- Reviewed existing signal patterns in `backend/api/signals.py`
- Analyzed admin alerting pattern in `backend/api/views_alerts.py`
- Checked local auth lockout tracking in `backend/api/models_local_auth.py`

### Key Findings
1. **django-axes** already configured:
   - `AXES_FAILURE_LIMIT=5` (lock after 5 failures)
   - `AXES_COOLOFF_TIME=1` hour lockout
   - `AXES_ENABLE_ACCESS_FAILURE_LOG=True`
   - Uses `AxesStandaloneBackend` for authentication

2. **Email infrastructure** exists:
   - `send_email()` and `send_email_async()` in `api/email.py`
   - Celery task `send_email_task` for async delivery
   - Templates in `backend/templates/email/`
   - `EmailLog` model for tracking

3. **Admin alerting** pattern exists:
   - `AlertListView` in `views_alerts.py` already checks for `account_locked` action
   - Aggregates alerts from audit, system, and webhook sources

4. **Local auth** has separate lockout tracking:
   - `LocalUserProfile.record_login_attempt()` tracks failures
   - `locked_until` field for lockout expiry
   - `failed_login_attempts` counter

### Implementation Plan Created
- 5 phases, 14 subtasks
- Phase 1: Core Infrastructure (settings, templates, tasks)
- Phase 2: Signal Integration (axes signals, local auth integration)
- Phase 3: Mass Lockout Detection (Redis tracking, admin alerts)
- Phase 4: Testing (unit tests, integration tests)
- Phase 5: Documentation

### Architecture Decisions
- Use django-axes `user_locked_out` signal for axes-based lockouts
- Send emails asynchronously via Celery (non-blocking)
- Use Redis sorted sets for time-windowed mass lockout detection
- Debounce admin alerts to prevent spam
- Leverage existing `AuditLog` model with `action='account_locked'`

## Phase 1: Core Infrastructure - Complete ✓

### Completed Subtasks

#### 1.1 - Add lockout notification settings ✓
- Added lockout notification configuration settings to `backend/config/settings/base.py`
- LOCKOUT_NOTIFICATION_ENABLED (default: true)
- LOCKOUT_ADMIN_EMAILS (default: empty list)
- LOCKOUT_MASS_THRESHOLD (default: 10)
- LOCKOUT_MASS_WINDOW_MINUTES (default: 5)
- All settings follow existing patterns with os.getenv() and proper defaults

#### 1.2 - Create lockout email template ✓
- Created HTML email template for user lockout notifications at `backend/templates/email/account_lockout.html`
- Template follows existing email patterns and includes:
  - Red warning styling (#dc2626) for security focus
  - Lockout duration, failed attempt count, IP address, and timestamp
  - Two-section guidance: "Was this you?" with different advice for legitimate vs suspicious attempts
  - Conditional password reset button with gradient styling
  - Security best practices section with green info box
  - Professional, user-friendly tone with clear security guidance

#### 1.3 - Create admin alert email template ✓
- Created HTML email template for admin mass lockout alerts at `backend/templates/email/mass_lockout_alert.html`
- Orange/red warning styling (#ea580c) for security urgency
- Alert summary with lockout count, time window, detection time, and threshold
- Table of affected accounts showing username, email, and lockout_time (no passwords)
- Conditional IP address summary section with IP and attempt count table
- Comprehensive 6-step recommended action plan for administrators
- Educational section explaining credential stuffing attacks
- Next steps section with specific tasks for incident response

#### 1.4 - Create lockout notification Celery tasks ✓
- Created `backend/api/tasks_lockout.py` with three Celery tasks following existing patterns
- `send_lockout_notification_task` - Sends email to affected user asynchronously
  - Accepts user_email, user_data, and lockout_data parameters
  - Uses existing send_email infrastructure
  - Respects LOCKOUT_NOTIFICATION_ENABLED setting
  - Includes detailed structured logging with task_id, user_email, and ip_address
- `send_admin_lockout_alert_task` - Sends mass lockout alerts to admin emails
  - Accepts lockout_count, time_window_minutes, affected_accounts, and ip_summary
  - Sends to all emails in LOCKOUT_ADMIN_EMAILS setting
  - Skips gracefully if no admin emails configured
  - Uses mass_lockout_alert.html template with comprehensive security guidance
- `check_mass_lockout_task` - Checks for mass lockout patterns and triggers alerts
  - Implements debouncing using Redis cache to prevent alert spam
  - Checks if lockout count exceeds LOCKOUT_MASS_THRESHOLD
  - Sets debounce key with TTL matching time window
  - Triggers admin alert task when threshold exceeded
  - Returns status dict with count, threshold, and alert status
- All tasks use standard retry configuration (max_retries=3, exponential backoff)
- All tasks use bind=True for access to task context (self.request.id)
- All tasks follow existing patterns from `backend/api/tasks.py`
- Proper error handling and structured logging throughout

## Phase 2: Signal Integration - In Progress

### Completed Subtasks

#### 2.1 - Create lockout signal handlers ✓
- Created `backend/api/signals_lockout.py` with handler for django-axes `user_locked_out` signal
- Signal handler implementation:
  - Uses `@receiver(user_locked_out)` decorator to listen to axes signals
  - Extracts user information (username, email, first_name) from User model
  - Gracefully handles cases where User object doesn't exist (logs warning, continues with username)
  - Extracts IP address and failure count from signal parameters and settings
  - Calculates lockout duration and unlock time from `AXES_COOLOFF_TIME` setting
  - Prepares comprehensive lockout_data dict with duration, failure count, IP, timestamps, reset URL
  - Prepares user_data dict with first_name, email, username for email personalization
- Audit logging:
  - Creates audit log entry with `action="account_locked"`
  - Includes metadata: IP address, failure count, lockout duration, unlock time, source
  - Uses `log_audit()` from `api.audit` following existing patterns
  - Sets both actor_id and resource_id to user_id (user attempted login)
- Notification triggering:
  - Triggers `send_lockout_notification_task.delay()` asynchronously via Celery
  - Only sends if user has email and `LOCKOUT_NOTIFICATION_ENABLED` is True
  - Logs reason if notification is skipped (no_email or disabled)
- Mass lockout tracking:
  - Increments Redis counter using `lockout_count:{window}m` key
  - Sets TTL on counter to expire after time window
  - Triggers `check_mass_lockout_task.delay()` with current count
  - Error handling prevents tracking failures from blocking signal handler
- Comprehensive structured logging throughout using structlog
- All acceptance criteria met

#### 2.2 - Connect lockout signals in app config ✓
- Successfully imported lockout signals in `backend/api/apps.py` ready() method
- Added `import api.signals_lockout  # noqa: F401` following existing pattern for api.signals
- Signal handlers in signals_lockout.py are now registered when Django app starts up
- Enables automatic account lockout notifications when django-axes user_locked_out signal is triggered
- Both apps.py and signals_lockout.py pass Python syntax validation
- All acceptance criteria met

#### 2.3 - Integrate with local auth lockout ✓
- Successfully integrated lockout notifications with `LocalUserProfile.record_login_attempt()` in `backend/api/models_local_auth.py`
- Implementation details:
  - Added lockout detection flag (`lockout_occurred`) that triggers when `failed_login_attempts >= max_attempts`
  - Created `_send_lockout_notification()` helper method following `signals_lockout.py` pattern
  - Sends notification email asynchronously using `send_lockout_notification_task.delay()`
  - Creates audit log entry with `action='account_locked'` and `source='local-auth'`
  - Increments mass lockout counter in Redis with TTL based on `LOCKOUT_MASS_WINDOW_MINUTES`
  - Triggers `check_mass_lockout_task.delay()` for mass attack detection
  - Handles users without email (checks `self.user.email` and `LOCKOUT_NOTIFICATION_ENABLED`)
  - Comprehensive structured logging with `local_auth_*` prefixes for easy filtering
  - Error handling for Redis tracking prevents failures from blocking the lockout process
- All acceptance criteria met:
  ✓ Notification triggered when locked_until is set
  ✓ Uses same notification task as axes integration (send_lockout_notification_task)
  ✓ Handles case where user doesn't have email
- Lockout duration formatting:
  - Displays hours if >= 1 hour (e.g., "1 hour", "2 hours")
  - Displays minutes if < 1 hour (e.g., "30 minutes")
- Follows DRY principle by extracting notification logic into reusable helper method
- Maintains consistency with django-axes signal handler implementation

## Phase 2: Signal Integration - Complete ✓

All signal integration subtasks completed. Both django-axes lockouts and local auth lockouts now trigger:
- User email notifications with security guidance
- Audit log entries for tracking
- Mass lockout detection for admin alerting

## Next Steps
- Begin Phase 3: Mass Lockout Detection
- Implement Redis-based lockout tracking utilities (3.1)
- Add mass lockout check to signal handler (3.2)
